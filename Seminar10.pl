/* 
HW задачки:
reverse(List, ReversedList).
*/


% reverse(List, ReversedList)
% O(n)
reverse(List, ReversedList) :- reverseHelper(List, [], ReversedList).

reverseHelper([], X, X).
reverseHelper([H | T], Curr, Res) :- reverseHelper(T, [H | Curr], Res).

/* S [H|L]
[H|S] L
[] L */

% O(n^2)
reverse1([],[]).
reverse1([H|T] , R):-
    reverse1(T,W),
    append(W,[H],R).

/*
Имаме друместен предикат p. X и Y са списъци. Напишете тези формули на Пролог:
a) \forall X \forall Y p(X,Y) Всеки ел. на Х е във всеки на Y.
b) \exists X \forall Y p(X,Y) Има ел. на Х, който е във всеки ел. на Y.
c) \forall X \exists Y p(X,Y) Всеки ел. ман Х е в ел. на Y.
d) \exists X \exists Y p(X,Y) Има елемент на Х, който е в елемент на Y
\exists -> \E
\forall -> \A
*/

% \forall x p(x) |=| \neg \exists x \neg p(x)
% not() unary predicate, \+()
% d)
d(X, Y):- member(X1, X), member(Y1, Y), member(X1, Y1).

% c)
c([], _).
c([H|T], Y):- member(Y1, Y), member(H, Y1), c(T, Y). 

c1(X, Y):- not(( member(X1,X), not(( member(Y1,Y), member(X1,Y1) )) )).

% b) \E x \A y p(x,y) |=| \E x \neg( \E y \neg (p(x,y)))
b(X, Y):- member(X1, X), allY(Y, X1).

allY([], _).
allY([H|T], X1):- member(X1, H), allY(T, X1).

% a) \A x \A y p(x,y) |=|  \neg( \E x \neg( \A y p(x,y) )) |=| \neg( \E x \neg(\neg y \neg p(x,y))) |=|
% |=| \neg( \E x \E y \neg p(x,y))
a([], _).
a([H|T], Y):- allY(Y, H), a(T, Y).

not2(A):-call(A), !, 0>1.
not2(_).
 
% HW разпишете a), b) и isSorted използвайки not()


% subset(List, Subset). 
infix(List, Infix) :-
    append(_, Infix, A),
    append(A, _, List).

isSubsetRecognizeSimpleSets([],[]).
isSubsetRecognizeSimpleSets(X,Y):-
    permutation(Y,R),
    infix(R,W),
    W = X.

isSubsetRecognizeMultiSets(X, Y):- not(( member(Z, X), not(member(Z, Y)) )).

% [1,2,z,a,d] -> [1,1,1,1,1]
% [1,z,a,d] -> [1,0,1,1,1]
subsetGenerator([], []). 
subsetGenerator(R, [_|T]):- subsetGenerator(R, T).
subsetGenerator([H|R], [H|T]):- subsetGenerator(R, T).

subsetGenerator2([], []). 
subsetGenerator2([H|T], S):-append(_, [H|S1], S), subsetGenerator2(T, S1).

% Генерираме всички списъци S, чиито елементи да елемнти на L.
% subsetGeneratorMultiSets(S, L).
% []
% [1]
% [1,1]

subsetGeneratorMultiSets([], _).
subsetGeneratorMultiSets([H|S], L):- subsetGeneratorMultiSets(S, L), member(H, L).
% ?-subsetGeneratorMultiSets(X, [1, 2, 3]).




/* 
HW:
toSet(A,B). // removeDuplicates(A,B).

Set operations:
inUnion(X, A, B).
inIntersection(X, A, B).
inDifference(X, A, B).
isSubsetOf(A, B).
areEqualSets(A, B).

Да се дефинират на пролог едноместни предикати q1, q2 , q3 и q4 .
такива че даден списък X:
(1) q1 разпознава дали празният списък е елемент на X,
(2) q2 разпознава дали X съдържа елементи Y и Z, които нямат общи
елементи,
(3) q3 разпознава дали X съдържа елемент Y, чиито елементи са
еленти на всички елемeнти на X,
(4) q4 разпознава дали за всеки елемент Y на X съществува такъв
елемент Z на X, че Y и Z нямат общи елемeнти.

 Да се дефинира на пролог предикат p(X, Y ),
който по даден списък от числа X и списък от списъци
от числа Y проверява дали са изпълнени следните три
условия: 1) X може да се представи като конкатенация
на два елемента на Y ; 2) X има четен брой елементи
и 3) сумата от елементите на X е последен елемент на
елемент на Y .

Да се дефинира на пролог предикат p(X, Y ),
който по даден списък X от списъци от числа намира та-
къв елемент Y на X, че Y не съдържа по-голям елемент от
най-големите елементи на елементите на X, и никой еле-
мент на X, притежаващ същото свойство, не е с повече
елементи от Y .

Да се дефинира на пролог предикат p(L, M ),
който по даден списък от числа L при преудовлетворяване
генерира в M всички списъци, такива че:
∙ множеството от елементите на M е подмножество на
множеството от елементите на L;
∙ за всеки елемент X на M съществува такъв елемент
Y на M , че множеството { X − Y, X ∗ Y, X + Y } е
подмножество на множеството от елементите на L.

Да се дефинира на пролог предикат p(L), който
по даден списък от различни списъци L проверява дали
всеки два различни елемента на L имат общ елемент, който
не принадлежи на някой елемент на L.

Да се дефинира на пролог предикат p(L), който
по даден списък от различни списъци L проверява дали
в L съществуват два различни елемента, които имат общ
елемент, който не принадлежи на никой друг елемент на L.

Казваме, че списък X мажорира списък Y , ако
всички елементи на X са елементи на Y . Да се дефинира
на пролог предикат p(L, M ), който по даден списък от спи-
съци L намира списък M , който съдържа всички елементи
на L и в който никой елемент не се мажорира от елемент,
намиращ се след него в списъка.

Да се дефинират предикати p(X), q(X) и r(X), та-
кива че ако X е списък от списъци, то
p(X) ⇐⇒ 5 е елемент на поне два елемента на X
q(X) ⇐⇒ всеки три елемента на X имат поне два различ-
ни общи елемента.
r(X) ⇐⇒ съществува такова ненулево естествено число n,
че X съдържа 2n различни по между си елемен-
ти, всеки от които има не повече от n елемента.

За произволен списък [a1 , a2, . . . , ak ] ще казваме, че
списъците от вида [am , am+1, . . . , am+i ], където 1 5 m 5 k и
0 5 m 5 k − m, са негови подспицъци. Да се дефинира пре-
дикат p(X, Y, Z), който по дадени списъци X и Y генерира
всички подсписъци Z на Y , такива че дължината на Z е
колкото дължината на X, всеки елемент на Z е по-голям от
елемента, намиращ се на същата позиция в X и последните
елементи на Z и Y са равни.

*/